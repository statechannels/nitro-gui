import { ChangeEvent, useEffect, useState } from "react";
import { NitroRpcClient } from "@statechannels/nitro-rpc-client";
import { PaymentChannelInfo } from "@statechannels/nitro-rpc-client/src/types";
import {
  Select,
  MenuItem,
  SelectChangeEvent,
  Button,
  TextField,
  Box,
  Table,
  TableRow,
  TableCell,
  TableBody,
  Checkbox,
  FormControlLabel,
} from "@mui/material";
import axios, { isAxiosError } from "axios";

const QUERY_KEY = "rpcUrl";

import "./App.css";

function App() {
  const retrievalProvider = "0xbbb676f9cff8d242e9eac39d063848807d3d1d94";
  const hub = "0x111a00868581f73ab42feef67d235ca09ca1e8db";
  const defaultUrl = "localhost:4005/api/v1";

  const url =
    new URLSearchParams(window.location.search).get(QUERY_KEY) ?? defaultUrl;

  const [nitroClient, setNitroClient] = useState<NitroRpcClient | null>(null);
  const [paymentChannels, setPaymentChannels] = useState<PaymentChannelInfo[]>(
    []
  );
  const [selectedChannel, setSelectedChannel] = useState<string>("");
  const [selectedChannelInfo, setSelectedChannelInfo] = useState<
    PaymentChannelInfo | undefined
  >();

  // This is the payload id for the payload generated by the ./sample/make-a-deal.sh from boost
  // Ideally we should just query boost/lotus for the list of available payloads
  const [payloadId, setPayloadId] = useState<string>(
    "bafk2bzacec3jst4tkh424chatp273o6rxvipfg54kphd56gaxobpcdtr2sgco"
  );

  const [paymentAmount, setPaymentAmount] = useState<number>(5);
  const [useBadSig, setUseBadSig] = useState<boolean>(false);
  const [errorText, setErrorText] = useState<string>("");

  useEffect(() => {
    NitroRpcClient.CreateHttpNitroClient(url).then((c) => setNitroClient(c));
  }, [url]);

  // Fetch all the payment channels for the retrieval provider
  useEffect(() => {
    if (nitroClient) {
      // TODO: We should consider adding a API function so this ins't as painful
      nitroClient.GetAllLedgerChannels().then((ledgers) => {
        for (const l of ledgers) {
          if (l.Balance.Them != hub) continue;

          nitroClient.GetPaymentChannelsByLedger(l.ID).then((payChs) => {
            const withProvider = payChs.filter(
              (p) => p.Balance.Payee == retrievalProvider
            );
            setPaymentChannels(withProvider);
          });
        }
      });
    }
  }, [nitroClient]);

  const updateChannelInfo = async (channelId: string) => {
    const paymentChannel = await nitroClient?.GetPaymentChannel(channelId);
    setSelectedChannelInfo(paymentChannel);
  };

  const handleSelectedChannelChanged = async (event: SelectChangeEvent) => {
    setSelectedChannel(event.target.value);
    updateChannelInfo(event.target.value);
  };

  const updatePayloadId = (e: ChangeEvent<HTMLInputElement>) => {
    setPayloadId(e.target.value);
  };

  const updatePaymentAmount = (e: ChangeEvent<HTMLInputElement>) => {
    setPaymentAmount(parseInt(e.target.value));
  };

  const handleUseBadSigChanged = (
    _: ChangeEvent<HTMLInputElement>,
    checked: boolean
  ) => {
    setUseBadSig(checked);
  };

  const triggerFileDownload = (blob: Blob, fileName: string) => {
    // This will prompt the browser to download the file

    const blobUrl = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = blobUrl;
    a.download = fileName;
    a.click();
    a.remove();
    window.URL.revokeObjectURL(blobUrl);
  };

  const fetchFile = async () => {
    setErrorText("");

    if (!nitroClient) {
      setErrorText("Nitro client not initialized");
      return;
    }
    if (!selectedChannel) {
      setErrorText("Please select a channel");
      return;
    }

    const voucher = await nitroClient.CreateVoucher(
      selectedChannel,
      paymentAmount
    );
    // TODO: Slightly hacky but we wait a beat before querying so we see the updated balance
    setTimeout(() => {
      updateChannelInfo(selectedChannel);
    }, 50);

    const signatureToUse = useBadSig
      ? // This was a valid signature for a voucher but it's not valid for our voucher
        "0xbfc7cede1b4251d3a97d6e381175cf64284055922f6d044f79939445449e748e769433e686126014648502ef51f6af444a8d41f82d572aaa94e196a28b5ede581c"
      : voucher.Signature;
    try {
      const result = await axios.get(
        `http://localhost:7777/ipfs/${payloadId}?channelId=${voucher.ChannelId}&amount=${voucher.Amount}&signature=${signatureToUse}`,
        {
          responseType: "blob", // This lets us download the file
          headers: {
            Accept: "*/*", // TODO: Do we need to specify this?
          },
        }
      );
      triggerFileDownload(result.data, "fetched-file-from-ipfs");
    } catch (e) {
      if (isAxiosError(e)) {
        const { message } = e;
        e.response?.data.text().then((text: string) => {
          setErrorText(`${message}: ${text}`);
        });
      } else {
        setErrorText(JSON.stringify(e));
      }
    }
  };

  return (
    <Box>
      <Box p={10} minHeight={200}>
        <Select
          label="virtual channels"
          onChange={handleSelectedChannelChanged}
          value={selectedChannel}
        >
          {...paymentChannels.map((p) => (
            <MenuItem value={p.ID}>{p.ID}</MenuItem>
          ))}
        </Select>

        <Table>
          <TableBody>
            <TableRow>
              <TableCell>Paid so far</TableCell>
              <TableCell>
                {selectedChannelInfo &&
                  // TODO: We shouldn't have to cast to a BigInt here, the client should return a BigInt
                  BigInt(selectedChannelInfo?.Balance.PaidSoFar).toString(10)}
              </TableCell>
            </TableRow>
            <TableRow>
              <TableCell>Remaining funds</TableCell>
              <TableCell>
                {selectedChannelInfo &&
                  // TODO: We shouldn't have to cast to a BigInt here, the client should return a BigInt
                  BigInt(selectedChannelInfo?.Balance.RemainingFunds).toString(
                    10
                  )}
              </TableCell>
            </TableRow>
            <TableRow>
              <TableCell>Payee</TableCell>
              <TableCell>
                {selectedChannelInfo && selectedChannelInfo.Balance.Payee}
              </TableCell>
            </TableRow>
            <TableRow>
              <TableCell>Payer</TableCell>
              <TableCell>
                {selectedChannelInfo && selectedChannelInfo.Balance.Payer}
              </TableCell>
            </TableRow>
          </TableBody>
        </Table>
      </Box>
      <Box>
        <TextField
          fullWidth={true}
          label="Payload Id"
          onChange={updatePayloadId}
          value={payloadId}
        ></TextField>
      </Box>
      <br></br>
      <Box>
        <FormControlLabel
          label="Use bad signature"
          control={
            <Checkbox
              onChange={handleUseBadSigChanged}
              value={useBadSig}
            ></Checkbox>
          }
        />
        <TextField
          label="Payment Amount"
          onChange={updatePaymentAmount}
          value={paymentAmount}
          type="number"
        ></TextField>
        <Button onClick={fetchFile}>Fetch</Button>
        <Box>{errorText}</Box>
      </Box>
    </Box>
  );
}

export default App;
